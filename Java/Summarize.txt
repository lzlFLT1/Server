Java 中对象全等性判断：
    1. obj.equals(obj2) 返回 true
    2. 对象的 hashCode() 方法一直

Java 中获取系统参数
    System.getProperties(); 方法上方包含所有属性 key
    
    
Java 中的字符编码问题
    .class 文件肯定是 unicode 编码


/*
JVM -- Java Virtrual Machine -- Java 虚拟机
JRE -- Java Runtime Environment -- Java 运行时环境
JDK -- Java Development Kit -- Java 开发工具包
1.java.lang包下的80％以上的类的功能的灵活运用。
2.java.util包下的80％以上的类的灵活运用，特别是集合类体系、正规表达式、时间、属性、和Timer.
3.java.io包下的60％以上的类的使用，理解IO体系的基于管道模型的设计思路以及常用IO类的特性和使用场合。
4.java.math包下的100％的内容。
5.java.net包下的60％以上的内容，对各个类的功能比较熟悉。
6.java.text包下的60％以上的内容，特别是各种格式化类。
7.熟练运用jdbc
8.java.security包下40％以上的内容，若对安全没了解，就不可能掌握java.
9.XML处理，熟悉SAX、DOM以及JDOM的优缺点并且能够使用其中的一种完成XML的解析及内容处理。
*/

/************************************** Java 知识点总结 ***********************************
 * 1、普通类、接口、抽象类、枚举类、final类、内部类（非静态嵌套类）、静态内部类、局部内部类、匿名内部类
 * 		内部类能定义 static 成员吗？
 * 2、继承
 * 		子类从父类继承了什么？
 * 		怎么调用父类的构造方法？
 * 		子类构造方法中第一句为什么必须是调用父类构造方法？
 * 3、方法的重载、重写
 * 		什么是多态？
 * 4、JVM
 * 		java类的加载机制是什么？
 * 		类的加载过程是什么样的？
 * 		类的初始化过程是什么？
 * 5、容器与泛型
 * 		基本容器的使用，
 * 		迭代器Iterator，
 * 		泛型边界，
 * 		自定义泛型方法，
 * 		自定义泛型类
 * 		泛型擦除
 * 6、异常：
 * 		java异常的层次结构是什么？
 * 		怎么自定义异常？
 * 		异常在函数调用中的传递机制是什么？
 * 		异常在多态中的传递机制是什么？
 * 		构造器异常会产生什么问题？
 * 7、反射机制
 * 		反射能破解类的访问权限吗？
 * 8、注解
 * 9、IO流
 * 10、多线程
 * 11、网络编程
 * 12、JDBC
 *
 *
 *
 *
 *************************************** Java 引用的四种状态 ********************
 * 强引用
 * 软引用
 * 弱引用
 * 虚引用
 *
 *

 *
 *************************************** Java 类的加载机制 ********************
 * 加载：
 * 		将类的class文件读入内存，并创建与之对应 的 java.lang.Class 的实例
 * 链接：
 * 		验证：文件格式、语法、语义等验证
 * 		准备：为static 修饰的静态域做默认初始化，并在方法区分配内存空间
 * 		解析：将符号引用替换为直接引用
 * （显示）初始化：
 * 		创建类的实例
 * 		访问类或接口的静态变量（final static 修饰的常量不会对类进行显示初始化）
 * 		调用类的静态方法
 * 		反射（Class.forName(packageName.className)）
 * 		初始化类的子类
 *		java虚拟机启动时被标明为启动类的类
 *
 *************************************** Java 中注意点  ********************
 * 1、Java 中所有函数都有两个隐式参数 this  super，其中this永远指向当前对象，super指向当前对象内包含的父类对象hr，hr是直接父类的对象
 * 2、所有 private 方法都隐式的声明为 final 方法
 * 3、所有的构造函数第一行代码永远是 super(args); 如果没有，说明隐式调用父类无参构造函数
 * 4、Java 中所有函数都有两个隐式参数 this  super，其中this永远指向当前对象，super指向当前对象内的子对象hr，且hr是直接父类的对象
 * */

/** Java 垃圾回收机制
 * JVM 有一个守护进程 System.gc();该守护进程：请求 JVM 进行垃圾回收，finalize()通常用于释放对象持有的资源
 * 当垃圾回收器确定不存在对该对象的更多引用时，由对象的垃圾回收器调用此方法。
 * //protected void finalize() throws Throwable { } //一旦垃圾回收器准备好释放对象内存是，将首先调用该方法，并在下一次垃圾回收时才真正回收内存
 * */