package kasei.javase.jvm;


/** todo JVM 架构总览
 * 1. 类加载系统：
 * 2. JVM 内存分区（运行时数据区）：
 * 3. 执行引擎
 * 4. JNI(Java Native Interface):
 * */

/** todo 类加载系统介绍
 * 第 1 步：装载，由 类加载器 从 源 加载 Java 字节码，其中 源 不仅仅只是 .class 文件，还包括网络流，总之是一切包含字节码的流
 *      Bootstrap ClassLoader: 负责加载位于bootstrap classpath下的类。
 *      Extension ClassLoader: 负责加载位于ext folder (jre\lib).下的类
 *      Application ClassLoader: 负责加载位于应用级别的路径，路径提到的环境变量等。
 *
 * 第 2 步：链接，包括 验证、准备、解析
 *      验证： 字节码验证器会验证字节码是否符合规范，如果不符合报错
 *      准备： 为所有的静态变量分配内存，并设置默认值，该默认不是代码中设置的值，是该类型的默认值
 *      解析： 字节码中所有的符号内存引用都被方法区的原始引用所取代。
 *
 * 第 3 步：初始化
 *      为所有的静态变量分配 初始值（代码中设置的值），静态代码块将被执行
 * */

/** todo 运行时数据区
 * 方法区： 所有的类级数据将被存储在这里，包括静态变量。每个JVM方法区只有一个，它是一个共享资源。(方法区中包含 常量池)
 *
 * 堆区： 所有的对象和他们相应的实例变量，数组都会被存储到这里，每个 JVM 堆区只有一个。由于方法区和堆区共享多个线程的内存，存储数据不是线程安全的。
 *
 * 栈区： 每一个线程，都会创建一个独立的运行时栈，对于每个方法调用，会在栈存储器中创建一个栈帧条目。所有的本地变量都会在栈内存汇总创建，说栈区域是线程安全的，因为它不是一个共享资源。栈帧被分为三个实体：
 *      a) 局部变量数组-相关方法的局部变量及其值将会存储在这里
 *      b) 操作数栈-如果需要任何中间操作，操作数栈将作为运行时工作区来执行操作。、
 *      c) 帧数据-对应于该方法的所有符号存储在这里。在任何异常情况下，捕获的信息将保持在帧数据中
 *
 * PC 寄存器： 每个线程都有一个独立的 PC 寄存器, 以保持当前执行指令的地址，一旦这条指令被执行，PC 寄存器就更新至下一条指令
 *
 * 本地方法栈：本地方法栈保存了本地方法信息，对于每一个线程，将创建一个单独的本地方法栈。
 * */

/** todo 执行引擎：经过运行时数据区分配的字节码被执行引擎执行。执行引擎阅读字节码，并一块一块地执行。
 *  解释器：
 *  JIT 编译器：
 *  垃圾回收：
 *  本地方法库：
 *  本地方法库接口：
 * */

