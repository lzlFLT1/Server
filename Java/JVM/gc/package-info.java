package kasei.javase.jvm.gc;

/** Garbage Collection(垃圾回收器)*/

/* java运行时区域中程序计数器、虚拟机栈、本地方法栈3个区域随线程生命周期结束而结束，
 * Java堆、方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，
 * 我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的是这部分内存。
 * */


/** 判断对象是否死亡：引用计数法，可达性分析法
 * 引用计数法：给对象加一个引用计数器，引用时 +1 ，失效时 -1，为 0 即可回收，解决不了循环引用问题
 * 可达性分析法：以图论来理解，就是从 GC Roots 到这个对象不可达时，回收这个对象
 *
 * GC Root 对象的种类：
 * 1. 虚拟机栈（栈帧中的本地变量表）中引用的对象
 * 2. 方法区中类静态属性引用的对象
 * 3. 方法区中常量引用的对象
 * 4. 本地方法栈 JNI（即一般说的 Native 方法）引用的对象
 *
 * 引用
 * 判定对象是否存活都与"引用"有关,Java对引用概念进行了扩充。
 * 强引用（Strong Reference）
 * 软引用（Soft Reference）
 * 弱引用（Weak Reference）
 * 虚引用（Phantom Reference）
 * */

System.gc(); // 手动调用垃圾回收器，这样垃圾对象就会尽可能快的被回收，避免垃圾回收器的延时
