package main.java.jvm;

/**
 *************************************** JVM 内存解析 *********************************
 * 程序计数器：
 * Java 虚拟机栈：
 * 本地方法栈：存放基本类型和引用；不可以被多个线程共享
 * 堆内存：存放 new 出来的对象；可以被多个线程共享
 * 方法区：存放类的代码、static变量
 * 字符串及常量池：存放字符串和常量（同一程序不同位置，完全相同的直接常量只有一份数据）
 * 
 * 
 * 浮点数内存表示：阶码符号位  阶码  尾数符号位  尾数
 * 变量内存分析：
 * 基本类型变量：int i=10;  内存表示：[i,10]
 * 引用类型变量：String str="qwer";  内存表示：[str,地址]-->[地址,"qwer"]
 * 
 * ***************************** Java 类加载全过程 ***************************************
 * 什么是类加载？
 * JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成JVM可以直接使用的Java类型的过程
 * 
 * Java 类加载全过程：
 * 1. 加载： 
 *      将class文件字节码内容加载到内存中，并将这些静态的数据转换成“方法区”中的运行时数据结构，
 *      （该数据结构包括：常量池、静态变量、静态方法、类代码；常量池中有类名、方法名、变量名）
 *      在“堆”中生成一个代表这个类的java.lang.Class对象，作为“方法区”中类数据的访问入口		

 * 2. 链接：
 * 		a).验证：确保加载的类信息符合JVM规范，没有安全方面的问题
 * 		b).准备：为 static 变量分配内存并设置初始值（0），这些内存都在“方法区”中分配
 * 		c).解析：虚拟机常量池内的符号引用替换为直接引用的过程
 * 
 * 3. 初始化：是执行类构造方法<cinit>()方法的过程（注意：不是类里面的构造函数）	
 * 		类构造方法<cinit>()是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
 * 		初始化类时，如果有父类未初始化，则先初始化其父类，	
 * 		虚拟机会保证每一个类构造方法<cinit>()在多线程环境中被正确的加锁和同步
 *      当访问一个Java类的静态域时，只有真正声明这个域的类才会被初始化
 * 
 * 4.执行main方法：
 * 		a).在栈中创建 main 方法的栈帧，栈帧中包含 main方法中的所有变量，
 * 			如果 main方法调用其他方法fun(),则创建fun()方法的栈帧，并且压入栈，
 * 			该栈帧在main方法栈帧之上
 * 		b).如果有创建对象的语句，则在“堆”中把创建对象所需的内存全部置0，然后创建并将对象地址给变量。
 * 
 * 5.常量在编译阶段就存入调用类的常量池里，所以调用常量不会发生类的初始化，但加载还是会执行的 
 * */

class K01Jvm {

}
