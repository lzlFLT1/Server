//////////////////////////运算符重载///////////////////////////
/*运算符：运算符其实是一种特殊的函数：称为运算符函数
 *不能被重载的运算符：（    .  ::     ?:   #    sizeof   typeid   .*         ）
 *只能被重载为类成员函数的运算符：（      =          []                ()         ->       ）
 *限定条件：若运算符被重载为类的成员函数，则只能是非静态成员函数
 **/



//类外运算符重载；@:代表运算符
int operator@(/*参数表*/){}

//类运算符重载
class X
{
	T1 operator@(T2 b);//二元运算符类成员函数重载声明
	/*这种方式要求运算符@左边的参数必须是一个X对象：因为@左边的参数由this指针自动传递,如：X a,b;  a=b+2;(正确)a=2+b;（错误：运算符成员函数的重载要求运算符左边必须为对象，‘2’不是对象）
	 *调用形式：a@b     其中a为X的对象
	 *编译后的形式：a.operator@(b)或operator(a,b)
	 **/


	T operator@();//一元运算符类成员函数重载声明
	/*一元运算符没有参数，它实际上包含一个隐含参数，即调用对象的this指针
	 *调用形式：a@  或   @a
	 *编译后形式：a.operator@()或operator(a)
	 */


	friend T1 operator@(T2 a,T3 b);//二元运算符类友元函数重载声明
	friend T1 operator@(T2 a);//一元运算符类友元函数重载声明


///////////////////////////特殊运算符重载：++和--////////////////////////////////////////
	X operator@(){}//前缀：调用形式：++a
	X operator@(int){}//后缀：调用形式a++
	friend  X operator@(X& a);//前缀
	friend X operator@(X& a,int)//后缀：后缀形式的一元运算符比前缀形式的一元运算符多一个形式参数，但这个参数不起任何作用只起到区别的作用


/////////////////////////////////////////重载‘=’赋值运算符：类的赋值运算函数operator=（）只能被重载为类的成员函数，且不能被继承////////////////////

//////////////////////////////////////重载[]/////////////////////////////
	X& operator[](int n);
	/*1、n为参数
	 *2、由于[]既可以出现在=左边，又可以出现在右边，所以重载运算符[]市场返回引用，因为返回引用的函数可以在=的左边调用
	 *3、[]只能被重载为类的非静态成员函数不能被重载为友元和普通函数
	 */

//////////////////////////////类型转换函数////////////////////////
	基本型->类类型：构造函数、
	类类型->基本型：类型转换函数
	//类型转换函数定义形式
	/*没有返回类型*/operator type(/*没有形参*/)
	{
		return type类型的数据;//必须返回将要转换的目的类型的数据
	}
	//调用形式：int r=a;//调用operator int(){return }:其中a为类X的对象


	friend X& operator<<(ostream& os,const X a);
	friend X& operator>>(istream& is,const X a);

};

////////////////////////////输入输出运算符重载：不能被重载为类的成员函数////////////////////////////
	//重载输入输出运算符是对类ostream和类istream功能的扩充，因为<<和>>是两个的类的成员函数：运算符是特殊的函数，
	//但是这两个运算符只能输出基本型，重载是把几个基本型组合在一块输出 
	X& operator<<(ostream& os,const X a)
	{
		os<<a.<<a.<<a.;//输出对象的实际成员函数
		return a;//返回X类的对象
	}


	X& operator>>(istream& is,X a)
	{
		is>>a.;//输入对象的实际成员函数
		return a;//返回X类的对象
	}