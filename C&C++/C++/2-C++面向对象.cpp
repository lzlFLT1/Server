////////////////////////////////     面向对象知识点区      ////////////////////////////////////

//C++中struct和class用法没有区别，知识struct中所有成员都是public
//类的私有成员和对象的私有成员要分清楚，类的私有成员，用 对象名.成员名  这种格式是不能访问的 类的私有成员只能用类的成员函数才能访问 而类必须先具象为对象才能使用
//作用域操作符  :: （Person::set）是不同文件之间声明函数类的归属


/* 类使用过程：
1、调用构造函数创建类对象
2、通过对象对成员变量和函数进行调用
3、调用析构函数删除对象
*/

/* 基类与派生类对象的关系：派生类中含有基类子对象
所以以下语句完全正确：设a1为基类对象，b1为派生类对象，pA为基类指针
	a1 = b1;//把派生类对象赋值给基类对象：实质是把b1内的基类子对象复制给a1
	pA = &b1;//把派生类对象的地址赋值给基类指针：实质是把b1内的子对象地址赋值给指针
	A& ra=b1;//用派生类对象作为基类对象的引用；实质是把ra作为b1中基类子对象的别名
	((B*)pA)->print();//可以通过强制转换把基类指针pA转换成子类指针，来访问子类的成员函数，如果不强制转换则只能访问子类中基类子对象的内容（即继承自基类的内容）
*/
class templet
{
	//this指针
	templet* this;
	
	//友元函数、类区
		//全局友元函数
		//成员友元函数
		//友元类
	
	//静态成员区
		//静态数据成员
		//静态成员函数
	
	//私有成员 
	
	//保护成员 
	
	//公有成员
	
	//构造函数 
		//无参构造函数
		//全部参数都指定了默认值的构造函数
		//复制构造函数
	
	//析构函数 
	
	//内联函数
	
	//const 类成员函数
	
	//虚函数
	
	//纯虚函数
	
	//运算符重载
}
/* 
继承：
	多继承
	虚拟继承
多态：
	重载（函数重载、运算符重载）
	重定义 
*/



class B;//友元类的向前声明

///////////////////////////////////////////////////////    类定义  ////////////////////////////////////////////////////////////////////
class B
{
	//静态成员区
	static void B::aac(char ch);
	//私有成员
	private:
		int bb;
		Person person1;//正确：类的数据成员可以使其他类（Person）的对象
		Person* obja2;//ok
		B* objb,&objr;//ok：类中数据成员可以是自身类的指针或引用
		B b1;//错误：类中数据成员不能是自身类的对象
		Person person4;
		
	//保护成员
	protected:
	
	//公共成员
	public:
		
		B();
		int hub(){}	
};

 
class Person 
{
	//this指针
	Person* this;//指向当前对象
	
	//友元函数、类区
	friend double abc();//友元全局函数：注意友元函数并不是类的成员函数，所以定义时不能用Person::abc限定函数名
	friend static void B::aac(char ch);//友元成员函数：说明B类的成员函数acc是Person类的友元函数B类成员函数作为Person类的友元时，必须先定义B类，

	friend class B;//B是Person的友元类：B的任何成员函数都能直接访问Person的私有成员
	
	//静态成员区
	static int count;//static类的静态成员：属于类，整个类只有一份，相当于类的全局变量，能够被类的所有对象共用
	static void aac(char ch);//静态成员函数：只能访问该类的静态成员
	
	//私有成员（默认类型）：只允许类自身成员函数访问，被继承后也不允许派生类成员直接访问
	private:  
		char name0[16];//类声明或定义时不能为类的数据成员赋值
		int age;
		
	//保护成员：自身类的作用跟private效果相同；若被派生类继承，相当于派生类自定义的一个私有成员，能被派生类直接访问，这就是与private的区别，但是不能被派生类外部函数直接访问，这是与public的区别	
	protected:
	
	//公有成员：允许外部函数访问
	public:	
	//构造函数：对象定义时用于给对象分配内存和初始化
		
		//对象数组：数组中的对象的类必须有默认构造函数 才能定义对象数组
		//默认构造函数包括：无参构造函数（构造函数1）和全部参数都指定了默认值的构造函数两种
		Person();//构造函数1:作用是为对象分配内存和初始化，若类中没有自定义构造函数则编译器自动形成默认构造函数
		Person(char name[]="my",int age=9);//构造函数2:带默认参数的构造函数
		Person(const Person& obj);//复制构造函数：用于根据已存在的对象初始化一个新建对象
		
	//析构函数：对象生存期结束时清理对象
		virtual ~Person(cout<<"Person类对象已销毁"<<endl;);
		//虚析构函数：在销毁通过基类指针或引用调用子类对象时，虚析构函数可以确保彻底回收对象占用的内存空间
														  	
		
	//内联函数：特性：遇到调用此函数时直接复制函数体到调用函数中；1、内联函数定义必须在调用前定义，声明没用2、函数体内含循环、switch、goto语句的函数不能作为内联函数3、函数代码量要少一般1-5行
		void setAge(/* Person* this, */int x)// 所有类的！非静态！成员函数都具有一个隐形的参数 Person* this,对象调用成员函数时自动把自己的地址通过this指针传递给成员函数；
		{
			this->age = x;
		}
		/*1、在类内直接定义函数：这种方式定义的函数如果符合内联函数条件，C++将自动设置成内联函数
		 *2、在非const成员函数：编译器自动添加的this指针格式为：Person* this没有const修饰符（对比 const 类成员函数 理解），不能给this指针赋值，但是可以通过它修改数据成员的值
		 */
		void printAge();//外部定义的内联函数
		
	//const 类成员函数：该函数不能修改数据成员的值
		int getAge(/* const Person* this, */)const;// const 类成员函数的隐形参数为  const Person* this,
		{
			int age;
			Person::age = 9;//类成员函数中局部变量名与类数据成员名冲突时，数据成员的使用格式
			return this->age;
		}
		/*1、函数尾部const表示：该函数为const成员函数
		 *2、const参数:表明是常量成员函数：表示不能修改数据成员的值，如const Person* this；表示不能通过this指针修改对象的数据成员
		 *参数表中注释部分是编译器编译过程中为成员函数自动添加的一个参数
		 *3、在类的const成员函数里，this被设置成const Person* this，不能通过它修改对象的数据成员值
		 */
		 
	//虚函数：函数重定义的基础
		/*1、虚函数运行机制：如果基类中的非静态成员函数被定义为虚函数，且子类重写了基类的虚函数，则通过指向基类对象的指针或引用，
		 *   调用子类对象中的虚函数时，就会调用到该指针（引用）实际所指对象的成员函数（即子类中重写的虚函数而不是基类中的虚函数）
		 *2、虚函数特性：
		 *   a、一旦某个类成员函数声明为虚函数后，该成员函数在子类的继承体系中就永远为虚函数，即使子类重写时没有声明时虚函数，它依然是虚函数
		 *   b、如果基类定义了虚函数，当且仅当通过基类指针或引用调用子类成员时才会体现虚函数特性，如果基类对象直接调用则依旧不能调用子类成员，只能调用基类子对象中的成员
		 *   c、虚函数只适合重写，即必须与基类虚函数的函数原型完全相同，否则则判定为函数重载，不属于虚函数范围
		 *   d、子类对象通过基类子对象的成员函数调用虚函数时，将调用子类中重写的虚函数，体现虚函数特性
		 *   e、静态成员函数，内联函数，构造函数不能定义为虚函数，析构函数却可以
		 *   f、虚析构函数：虽然子类类名C和基类类名Person不同，但是~C（）却可以看做是基类虚析构函数~Person（）在子类中的重写
		 */
		void f(){whoAmI();}
		virtual void whoAmI(){cout<<"人类";}
		
	//纯虚函数：在基类中声明，但在基类中不提供具体实现代码，要求它的子类为纯虚函数提供实现代码
		virtual int fun(int ,char)=0;//纯虚函数定义格式	
		
	//运算符重载
		Person operator +(const Person& a, const Person& b){}
};


//////////////////////////////////////////   函数定义区   ///////////////////////////////////////////////////////////
//友元函数或全局函数定义
double abc(){}//友元函数定义，不能用Person::abc限定函数名

//静态成员定义
int Person::age = 9;//静态数据成员定义（必须在类外部定义）：若未赋初值，则默认为0
static void Person::aac(char ch){}//静态成员函数定义


// 成员函数定义，包括构造函数
Person::Person(){}
Person::Person(char name[], int age):name0(name),age(age){}//使用初始化列表来初始化字段
/*构造函数中成员初始化列表（即':'与{}之间的内容）：表示把括号中的初始值参数赋值给括号前的成员
 *1、初始化列表中的成员初构造次序跟它们在类中的声明顺序相同，跟在初始化列表的位置无关，销毁次序则相反
 *2、构造函数初始化列表先于函数体中的语句执行
 *3、const int i;（常量成员）int& k;（引用成员）B bb;（类对象成员） 派生类构造函数对基类构造函数的调用 这4类成员必须采用初始化列表进行初始化
 */
Person::Person(const Person& person1){}//复制构造函数定义

Person::~Person(){}//析构函数定义

inline void printAge()
{
	cout <<this->age; 
}

void setAge(/*const Person* this*/,int a,char [],float& )const
{
	this->age = age;
}



B::B():person4(){}//给类的成员对象person4初始化 必须使用初始化列表形式,因为成员初始化列表执行优先于构造函数体的执行

C::C():Person("ksf",21),r(5){}//子类C的构造函数:子类只能采用构造函数初始化列表的方式向基类或成员对象的构造函数传递参数




/////////////////////////////继承本质：即复制一份基类的所有成员到子类中去（不管何种继承子类中都存在所有基类成员的备份）////////////////////////
/*继承格式：public、private、protected
 *1、public继承：基类成员访问权限在子类中保持不变，但子类不能直接访问基类的私有成员
 *2、protected继承：基类的public成员全部变成子类的protected成员，其他保持原状
 *3、private继承：基类成员访问权限全部变成private，且子类成员不能直接访问基类私有成员，但可以直接访问基类公有成员和保护成员
 */
class C:virtual protected Person
{
		int r;
	public:
		// C++ 多态的实现
		void aac(char ch,int i);//重载：与基类Person中的aac成员函数重名，但是参数表不同，所以是重载
		void aac(char ch);//重定义：与基类Person中的aac成员函数重名,而且参数表也相同，所以是重定义
		/*不管子类对基类成员函数是重定义还是重载，都会覆盖掉基类的成员函数：
		 *即在使用kk.aac('y');或kk.aac('y',8);这两种种方式调用时，调用的是C类中的aac函数，而不是基类中的aac函数(kk为C类的对象：C kk;)
		 *若想调用基类的成员函数aac则使用格式为：kk.Person::aac('y');此种方式调用
		 */

		C();/*子类可以不定义构造函数的情况：
			 *1、基类没有定义任何构造函数；
			 *2、基类具有默认构造函数；
			 *C++一条规则：子类只负责直接基类的初始化工作（即基类的基类的初始化不需要子类定义）
			 */

		~C(cout<<"C类对象已销毁"<<endl;);//该析构函数是虚函数，因为C类的基类Person类的析构函数是虚函数，所以其所有子类析构函数全部是虚函数

		int hub(){}

		void whoAmI(){cout<<"畜生";}
};

class D:public B,protected C,virtual private Person/*多继承基类构造次序：先左边后右边即先B后C
												   *virtual虚拟继承：防止D的派生类E在多继承时，同时以其他Person类的子类作为基类继承，
												   *                 如C类（即同时以C和D两个当做基类）											   
												   *                 造成Person类的数据在派生类E中有多个数据备份，造成重复
												   */
{
	B::hub();
	C::hub();//多继承中两个基类具有同名函数，在调用时必须加上基类前缀
};


class E:public C,private D/*C、D两个基类都继承自Person类，但都是虚拟继承，所以E类中只有一份Person类的数据，其中称Person类为（虚基类），
						   *而E类称为（最终派生类）
						   *虚拟继承构造函数调用优先级：先调用虚基类构造函数再调用非虚基类；虚基类的初始化由最终派生类E构造函数初始化
						   */
{
};



///////////////////抽象类/////////////////////////
/*1、只要含有一个纯虚函数的类就叫抽象类
 *2、抽象类不能建立对象
 *3、抽象类只能作为其他类的基类，通过抽象类对象的指针或引用（不能定义对象不代表不能定义指针和引用）可以访问到它的子类对象。
 *4、如果子类只是简单的继承纯虚函数，而没有实现该函数，则该子类也是抽象类
 */
class F
{
	
	//纯虚函数：在基类中声明，但在基类中不提供具体实现代码，要求它的子类为纯虚函数提供实现代码
	virtual int fun(int ,char)=0;//纯虚函数定义格式

};


//////////////////////////////////////////////    调用演示区    //////////////////////////////////////////////////////
//类对象的定义
类名  对象名;//调用默认构造函数
类名  对象名（实参表）;//调用普通构造函数
类名  对象名（已定义的对象）;//调用复制构造函数

Person ari;//调用构造函数1
Person anne(anne,9);//调用构造函数2

Person *Person_ptr;//定义类指针

//'.' 用于明确的类对象或结构体变量对自身成员的访问
ari.age = 17;//类数据访问
a = ari.getAge();//类成员函数调用

//'->' 用于类对象或结构体的指针变量对成员的访问
Person_ptr->age = 6;


//对象赋值
对象名1=对象名2;//两对象类型必须一致，对象赋值就是进行数据成员值的复制传递


//类的静态成员
Person::age;//静态数据成员访问：此种方法只能用于静态成员
对象名.age;//静态数据成员访问
Person::aac(ch);//类的静态成员函数访问方法1：
对象名.aac(ch);//类的静态成员函数访问方法2：






