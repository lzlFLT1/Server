//程序调试方法：
1、设置并执行print、cout等能直观看见的命令进行程序测试
2、逐行执行或设置断点执行程序；查看断点处各个变量的值与预期值比较；重复此过程

 /*标识符命名惯例：
 *常量（const）：全部大写
 *类：大驼峰HumanBoy
 *方法：小驼峰getName
 *局部变量：小驼峰
 */
 
/*自动类型转换（即隐式转换：这tm的是个坑爹的玩意儿）
 *1、类型相同，运算结果出现其他类型，将继续保持原类型（如 int / int，出现小数时，将自动转化为 int 造成精度降低）
 *   c = (double)(2/3)  c = 0.000  而  c = ((double)2/3)  c = 0.6666  说明 运算结果的 隐式转换 早于 强制转换
 *2、参与运算的数据类型不同，必须先转换成同一类型，才能进行运算；
 *   按数据长度增加的方向进行，以保证精度不降低。低字节-->高字节   有符号-->无符号
 *3、所有的浮点运算都是以双精度进行的，即使仅含float单精度量运算的表达式，也要先转换成double型，再作运算。
 *4、char型和short型参与运算时，必须先转换成int型。
 *5、在赋值运算中，赋值号两边量的数据类型不同时，赋值号右边量的类型将转换为左边量的类型。
 *   如果右边量的数据类型长度左边长时，将丢失一部分数据，这样会降低精度，丢失的部分按四舍五入向前舍入。
 */
 
/*C&C++定义的理解：
 *定义可以看成两种：类型定义，数据定义
 *类型定义不分配内存的，比如类的定义，结构体的定义，它是定义一个数据类型而已
 *数据定义分配内存，比如类对象定义，基本类型变量定义（包括指针，但是指针如果指向的内存地址没有被分配无法保存内容的）
 *一个原则：
 *不分配内存的，放在头文件
 *分配内存的放在cpp文件，防止重复定义
 */
 
//C&C++ 变量、对象使用步骤：声明 -> 定义（分配内存）-> 调用
//数据类型不匹配不能相互赋值，必须强制转换


 //////////////////////程序运行在内存形式简介/////////////////////////
/*一个程序在运行期间，它的程序代码和数据会被分别存储在4个不同的内存区域，分别为：
 *程序代码区：程序代码（即程序的各种函数代码）存放在此区域
 *全局数据区：程序的全局数据（如全局变量）和静态数据（static）存放在此区域！！编译器默认赋初值为0
 *栈区：程序的局部数据（在函数中定义的数据）存放在此区域中！！返回一个局部变量的引用和指针时要注意变量生存周期
 *堆区：程序动态数据（new或malloc就在此区域中分配存储空间）存放在此区域中
 */

/////////////////////变量生存期和作用域/////////////////
/*1、局部对象和静态对象的构造次序与他们在块中的声明次序相同
 *2、全局对象在main之前构造，在main结束之后销毁
 *3、对象数据成员，构造次序与在类中声明次序相同，销毁则相反
 */
 
/*条件编译：……………………………………………………………………………………………………………… */
#ifdef 标识符
	程序段1
#else 
	程序段2
#endif

#ifndef 标识符//当标识符没有被定义过时，编译程序段1
	程序段1
#else 
	程序段2
#endif

#if 表达式//当表达式值为真时，编译程序段1
	程序段1
#else 
	程序段2
#endif

/*宏定义：……………………………………………………………………………………………………………*/
	#define PI 3.1415926 //符号常量：原样替换
	#define S(a,b) (a*b)//#define 宏名（参数表）  字符串

/*文件包含：……………………………………………………………………………………………………………*/
	#include"0-HEAD.h"//是用 HEAD.h 中的所有内容替换这行代码
//C
	#include<stdio.h>
	#include<stdlib.h>
	#include<string.h>
	#include<stdarg.h>
	#include<conio.h>
//C++
	#include <iostream>
	#include <fstream>
	#include <iomanip>
	#include <cmath>

/*全局变量：…………………………………………………………………………………………………………………………………………………………………………………………………………*/  
	

	
	
/*函数声明（包含本项目中其他文件中的函数时,必须使用extern关键字）：…………………………………………………*/
	extern int JieCheng(int s); //在文件中调用其他文件的函数时必须加上此代码
 
/*程序主体：………………………………………………………………………………………………………………*/

	
///////////////////////   main 函数参数介绍   ///////////////////////////
int main(int argc,char *argv[])/* main的两个参数从OS命令行中获得
							      argc参数表示了命令行中参数的个数(注意：文件名本身也算一个参数)
							      argc的值是在输入命令行时由系统按实际参数的个数自动赋予的，
								  argv[0] 存储程序的名称，argv[1] 是一个指向第一个命令行参数的指针
								  如果没有提供任何参数，argc 将为 1，否则，如果传递了一个参数，argc 将被设置为 2
								  如果参数本身带有空格，那么传递参数的时候应把参数放置在双引号 "" 或单引号 '' 内部
								*/
{
	int i;//用于循环计数
	for(i = 0; i < argc; i++)
	{
		//命令行输入：本文件名  ksf "love wlt"
		printf("命令行第%d个参数为：%s\n",*arg[i]);
	}
	return 0;
}
	
////////////////////////   变量作用域与生存期    ///////////////////////////////////////////////////////////
	int Global;
	/*全局变量：所有源文件皆可使用；在别的文件使用时需先用extern int a;重新声明才可使用;
	 *生存周期：程序开始运行到结束;
	 */ 

	static int Static_Global;
	/*静态全局变量：仅可在本文件中使用的全局变量；
	 *生存周期：程序开始运行到结束；
	 */
	 
	int fun()
	{
		char str[9];//一个字符串
		/*普通局部变量：仅在本函数中使用；
		 *生存周期；本函数开始执行到结束；
		 */
		
		static int Static_d;
		/*静态局部变量：仅在本函数中使用，其他函数不能使用该变量；
		 *生存周期：程序开始运行到结束；
		 *特性：只初始化一次，默认值为0；
		 */
		 
		const float pi = 3.1415926 ////constant类型：表示赋值一次后不能再次对值进行修改,常变量：变量存在期间其值不能改变
		
		extern int ABB;//调用其他文件中的ABB全局变量必须先敲这段代码
	}
	
	
////////////////////////////   C++ 数据类型   //////////////////////////////////////////////////////////////////
	x = (int)9.87;//强制转换
	
	void //无类型
	bool  bool_variable = true;
	char  str[10] = "hello world";//C 字符串
	string str1 = "hello world!";//C++ 字符串类
	int i = 0;
	float f = 0.0;
	double d = 0.0;
	wchar_t   //宽字符型
	
	
	struct Person//结构体声明 
	{ 
		char name[9];
	}Anna;
	struct Person Bob;//结构体变量声明定义
	Bob.name = "Bob";
	struct Person *Person_ptr;//结构体指针声明定义
	Person_ptr->name = "Bob";
	
	
	enum month_week //枚举型声明
	{
		january=2,february,march,april,may=13,june,july,august,september,october,november,december,
		monday,tuesday,wednesday,thursday,friday,saturday,sunday
	}kk;
	
	
	struct packed_data //位段声明
	{/*1、位段成员必须是unsigned或int型
	  *2、位段赋值时应该注意位段取值范围，长度为n的位段取值范围为0~（2^n-1）
	  *3、一个位段只能存在一个字节之内，若下一个位段存不下则另起一个字节来存
	  *4、位段的赋值和读取都是通过整型来的，如给data.b=6赋值,则b位段内容为“0110”，读取出来的也是整型
	  */
		unsigned a:2;
		int b:4;
		unsigned :0;//长度为0的无名位段表示从另一个字节开始存
		unsigned c:3;
		unsigned :3;//无名位段表示这3位空间不用
		unsigned d:2;
	}data;
	
	
	/* 数组 其实是一组内存地址连续指针 */
	char str[9] = "luoyu";
	int array[2][3][3] = {{{2,3,4},{5,6,7},{8,9,10}},{{1,3,6},{23,54,2},{6,32,75}}};
	int *array[];//指针数组
	array[1][2][3];
	
	
	
	/* 指针 */
	char *ch_ptr;
	struct Person *Person_ptr;//结构体指针声明定义
	
	int *array_ptr1;//一维数组指针
	int (*array_ptr2)[];//二维数组行指针

	int **var;//指向指针的指针
	
	int (*fun_ptr)();//函数指针
	
	
	
	
	int *ptr = 0;//0可以给指针赋初值，表示空指针
	void *ptr;//除了函数指针不能给p赋值 其他类型都可以给p赋值
	ptr = ptr+7;
	
	ptr = &a;//&：取a地址存到p指针变量中,指针类型必须和所存的变量类型一致，如：a和p都是int类型
	c = *ptr;//那么c=0,即取出a的内容赋值给c
	
	//变量定义时按修饰符的顺序读 和 理解 就对了：const 读作  常量；  char*  读作字符指针 
	const char* pc = "duang";//常量指针：即指针变量pc中存的地址所指向的内容不可修改 即：*pc = "ff"  出错
	char* const pc = "duang";//指针常量：即指针变量pc中存的地址不能改变，如：pc++  出错 
	const char* const pc = "duang";//指向常量的常量指针
	
	int *p;
	const int i = 9;
	p = &i;//出错：不能将非const对象的指针指向一个const常量对象

	const int* p;
	int i = 9;
	p = &i;
	*p = 6;//出错：因为p是指向常量的指针，所以就算p能被非常量i当做指针，但是不能通过*p改变内存内容，因为p是指向常量的指针，p所指向的内存是常量不能改变



	
	/* 引用 */
	//引用必须在创建时被初始化
	//一旦引用被初始化为一个对象，就不能被指向到另一个对象
	int &quote = i;
	double &cite = d;
	
	int i=9;
	int& r=i;//在变量声明时出现的&才是引用运算符，其他地方都是取地址操作符

	int i=0;
	int a[10];
	int& aa=a;//错误，不能建立数组的引用
	int& ia[5];//错误：不能建立引用数组

	int&* ip=i;//错误：不能建立指向引用的指针（编译从左向右，哪个在左边哪个先起作用，除非优先级不一样）
	int&& ii=i;//错误：不能建立引用的引用
	int* pi=&r;//正确：//pi指针中存的其实是i变量的地址
	int*& pr=pi;//正确：pr是指针的引用
				//不能建立函数的引用

	
/////////////////////////   C&C++ 函数   //////////////////////////////////////////
/* 
函数定义格式：
返回类型 函数调用方法  函数名(参数类型 参数1，参数类型 参数2，...){}
int __stdcall funName(char c, int arry[], ...){}

函数调用方法：
用于说明在参数传递中的两个重要：
1. 当参数个数多于一个时，按照什么顺序把参数压入堆栈；
2. 函数调用后，由谁来把堆栈恢复原状。

__cdecl  C语言默认函数调用方法
__stdcall C++默认函数调用方法
*/

	void __stdcall fun(char c, struct person Anna, int arry[], int array[][6], float* ptr, float& x){}//普通全局函数,最后一个参数为传引用调用	

	struct person fun(){}//返回结构体的函数
	int* fun()//返回指针的函数
	{	
		static int array[7];//C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 static 变量
		return array;
	}
	float& fun(){}//返回引用,不能是函数的普通局部变量
	int main()
	{
		fun() = 2;//当函数返回一个引用时，则返回一个指向返回值的隐式指针。这样，函数就可以放在赋值语句的左边
	}


	int jiecheng(int x)//递归实例
	{
		if(x == 1){ return x;}
		return x*jiecheng(x - 1);
	}
	
	static int Static_fun(){}//静态函数：只能被本文件中的其他函数访问
	int f(int i,const int j){}//其中const表示：常量参数：禁止函数对参数的修改
	double sqrt(double f,int t=1,char ch='a');/*函数默认参数：如果函数有声明，则必须在声明中设定默认值，如果没有声明则在函数定义时指定
										   *具有多个默认参数的函数：所有默认参数都必须靠右，且中间不能参杂非默认参数
										   *调用具有默认参数的函数时，若省略某个实参，其右边的所有参数必须全部省略，其左边的默认参数不准省略
										   */
										   
	//函数重载：函数名可以相同，但是参数表必定不同，即总体上还是唯一的，只有返回值不同不能称为重载
	int jia(int a,int b){return a+b;}
	int jia(int a,int b,int c){return a+b+c;}
	
	//内联函数：特性：遇到调用此函数时直接复制函数体到调用函数中；1、内联函数定义必须在调用前定义，声明没用2、函数体内含循环、switch、goto语句的函数不能作为内联函数3、函数代码量要少一般1-5行
	inline int qiu_ti_ji(float chang,float kuan,float gao)
	{
		return chang*kuan*gao;
	}
	//可变长参数表函数：定义格式：返回类型  函数名（类型  变量名=值，……）；特性：在传递参数时可省略参数，但要改第4个参数，必须把前3个参数全写上，后面的可以省略
	void drawLine(char symbol='%',int num_symb=25,int num_lines=1);
	
	
	
	
	
	
//////////////////////////////   C&C++标准输入输出    ////////////////////////////////////////////////////////////
	/* C标准输入输出 */
	printf("请输入数据（字符,整数,浮点数,字符串）：");
	scanf("%c,%d,%s,%f",&c,&d,&f,&str);
	printf("\n输入值为：字符：%c，整数：%d，浮点数：%f，字符串：%s，打印%：%%",c,d,f,str);
	
	printf("\n请输入一个字符！：");
	c = getchar();//从流中读入一个字符
	putchar(c);//输出一个字符

	printf("\n请输入一个字符串！：");
	str = gets();
	puts(str);
	
	printf("\n请输入一个不需要回车即接收的字符！：");
	c = getch();//不需要回车即接收，#include<conio.h>
	printf("\n请输入一个不需要回车即接收,并回显的字符！：");
	c = getche();//不需要回车即接收，并回显,#include<conio.h>
	
	
	/* C++标准输入输出 */
	
	cin >>x >>y >>z;/*多个数据间用一个或多个空白符（空格、回车、tab）作为间隔符，输入完成后按Enter键结束，并在字符串末尾添加'\0'；
				  *换行：垂直位置下移一格，水平位置不变；回车：垂直位置不变，水平位置回到行开头windows下enter键同时执行\n\r
				  *假设输入35.4A：则x=35（类型检测int型不会读入小数点），y=0.4（0系统自动添加），z=A；
				  *（读取时忽略前面所有空白符，遇到正负号、小数点或者数字开始读入，并在遇到空白符或其他非数字字符时停止）
				  */
	cin.get//用于从键盘获取一个输入字符
	cin.get(ch)//从流中取出一个字符（不管是什么字符）放入ch中
	cin.getline(char* c,int n,char='\n')//从流中读取n-1个字符到数组c中，遇到特定字符结束，默认为‘\n’，取出的流中的'\n'字符抛弃
	cin.ignore//清空流中的数据


	cout <<'A' <<"love \t \n" <<9 <<x <<endl;//\n换行符；\t水平制表符\r回车
	cout <<std::hex <<17 <<"设置输出进制hex 16，oct 8进制，dec 二进制"
		 <<std::setprecision(3) <<3.1415926 <<"设置浮点数精度为3"
		 <<std::setw(8) <<"设置每个数据占用的列数，只对紧跟其后的一个数据有效"
		 <<std::setiosflags(std::ios::left) <<"设置对齐方式例子为左对齐，右对齐std::setiosflags(std::ios::right)" 
		 <<std::resetiosflags(std::ios::left) <<endl;
	std::cout.fill('*');//效果与下一条语句一样
	std::cout <<std:setfill('*') <<"设置填充字符，C++默认填充为空格" <<endl;

	
	
////////////////////////   C&C++ 运算符   ////////////////////////////////////////////////////////////////
	x%y;//xy必须均为int型，且y!=0
	sizeof(a);//返回变量所占用的字节数
    sizeof(int);//返回int类型所占用的字节数
	
	F_temp=9.0/5.0*C_temp+32.0;/*如果9.0/5.0换成9/5那么结果就不是1.4而是1，即9/5=1，
							    *因为机器把不带小数点的数自动当成int型，从而使小数点后面部分舍去了
							    */
	
////////////////////////////////////   C&C++ 流程控制   //////////////////////////////////////////////////////////////
	
	result=(first=2,second=first+1);//逗号表达式，顺序执行，整个逗号表达式的值为最后一个表达式的值：先执行first=2，再执行第二个，最终result=3，
	
	y = x>=10 ? 100 : 200;//x>=10成立则y=100否则y=200，（x>=10?100:200）是一个整体的表达式	
		
	if(&&  ||  !)
	{}
	else if()
	{}
	else 
	{}
	
	switch()
	{
	case int|char:
		break;//如果缺少break会将之后的case代码一起执行，直到遇到break或者switch结束

	case int|char:
		break;

	default:
		break;
	}

	while()
	{
		break;
		continue;
		goto LOOP;//无条件跳转到LOOP标号处
	}

	do
	{}
	while();

	for(sum=0,i=1;i<100;i++)
	{}

LOOP:
	sum = JieCheng(s);//调用文件外函数
	
	return 0;//只要函数执行到这一行代码，就代表该函数结束
}







///////////////////   C++ 动态内存分配   //////////////////////////
	int *p;

	p=new int;//分配1个int的堆内存
	p=new int(9);//将分配到的堆内存初始化为9
	delete p;//释放单个内存

	p=new int[10];//分配具有10个元素的数组
	delete []p;//释放数组内存
	
	//类
	p=new Human(3,7);//直接调用类的构造函数
	delete p;

	
	
////////////////////////命名空间////////////////////////////////
namespace myOwn//命名空间的定义
{
	int rand();
};
using namespace std;//引用命名空间全部成员
using namespace myOwn::rand();//引用命名空间的单个成员

int myOwn::rand()//命名空间的调用
{ 
	return 42;
}
int fun()
{
	srand(123);

	int stdNumber=rand();//stdnumber为系统给的随机数
	int myNumber=myOwn::rand();//mynumber为42
	y=(char) sy;//强制转换
}
	

	
/* C 文件： */
	FILE *fp;//文件指针定义
	fp = fopen("data.99","a+b");//以读写二进制方式打开文件data.99；出错返回NULL，正常返回文件指针
				/*FILE* fopen(文件名，使用文件方式)；
			    *打开方式：
				*t：以文本方式打开文件（默认）
				*b:以二进制方式打开文件
				******
				*r：以只读方式打开文件，文件若不存在返回错误信息
				*w：以只写方式打开文件，文件不存在则新建，文件存在，删掉再新建
				*a：以添加方式打开文件，打开文件时位置指针在文件尾，用于添加内容；文件不存在则新建
				*r+:读写方式打开，位置指针在文件头，不存在则新建
				*w+：读写方式创建一个新文件
				*a+：读写方式打开，位置指针在文件尾
				*/
	/*文件指针：stdin指向键盘
			  ：stdout指向显示器
		      ：stderr指向显示器
			*/
	fclose(fp);//返回值为0正常，为EOF（-1）出错	
	
	
	
	ofstream outData;//定义输出文件流变量
	ifstream inData;//定义输入文件流变量
	inData.open("c:\\DK\\ab.txt",ios::app);/*将文件流变量和磁盘文件关联起来
										   *打开方式有：
										   *ios::in				打开输入文件，ifstream类型变量的默认方式
										   *ios::out			建立输出文件，ofstream类型变量的默认方式
										   *ios::app			增加方式，若文件存在，在文件尾增加数据，不存在则新建
										   *ios::trunk			若文件已存在，文件已有内容将被清除
										   *ios::nocreate		若文件不存在，打开操作失败
										   *ios::noreplace		若文件存在，打开操作失败
										   */
	ifstream inData("c:\\DK\\ab.txt",ios::app);//此条代码与上面两条代码效果等同、
	//文件的读写也用'<<''>>'这两个操作符，在语句中嵌入文件流变量>>inData或<<outData就可以使用
	inData.close();//关闭文件
	outData.close();